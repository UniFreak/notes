Sed: Stream EDitor, **流编辑器**, 区别于**交互式编辑器**, 通过预先提供的规则编辑数据流

**模式空间(pattern space)**是 sed 执行命令时保存待检查文本的一块缓冲区

**保持空间(hold space)**是 sed 处理模式空间中的某些行时, 用来临时保存一些行的缓冲区

# 选项

Sed 默认不会修改文件数据, 只是发送到 STDOUT

`sed option script file`
    `-i`
    `-e script`
    `-f file`
    `-n`

**sed 命令**放到单引号中

使用 `-e` 可指定多条命令, 用 `;` 分开, 命令末尾和 `;` 之间**不能有空格**
可以写到一行: `sed -e 's/brown/green/; s/dog/cat' file`
也可以分开多行. 记住**必须在封尾引号所在行结束命令**

```sh
sed -e '
s/brown/green/
s/dog/cat' file
```

`-f` 选项可以指定命令文件, 文件中的命令**不用分号**, 文件一般命名为 `.sed` 后缀

`-n` 选项能抑制命令输出

# 行寻址

sed 命令默认作用于所有文本行, 可使用**行寻址**指定行

指定形式

1. 数字: 如单行 `2`, 区间 `2,4`, 到尾行 `2,$`
2. 文本模式过滤器: 如单行 `/pattern/cmd`, 区间 `/start_pattern/,/end_pattern/cmd`, sed **只支持 BRE**

以上两种指定形式, 可用于单个命令或命令分组

1. 单个命令 `[address]cmd`
2. 命令分组, 注意**必须在 `{` 后换行, 在 `}` 前换行**, 若多个命令在同一行, 可用 `;` 分割

```sh
addres {
    cmd1
    cmd2
    ...
}
```

# sed 编辑器命令

## 单行命令

- 替换: `[address]s/pattern/replacement/flags`

可以**使用其他字符**作为字符串分隔符, 如 `s!/bin/bash!/bin/csh!`

flags:
`数字` 指定替换第几个匹配. 默认第一个
`g` 替换所有匹配
`p` 打印原行, 通常配合 `-n` 选项, 以只输出替换过的行
`w file` 写入替换后行到文件

- 删除: `[address]d`

全部: `d`
单行: `3d`
区间: `2,3d`, `2,$d`
模式匹配: `/pattern/d`
模式匹配区间: `/begin_pattern/,/end_pattern/d` **每次**匹配了 begin_pattern, 就会开始删除

- 插入/追加/修改: **必须用 `\`**另起一行指定插入的内容, 或指定多行内容

```sh
# 插入: i
sed '[address]i\
new line\
multiple line
'

# 追加: a
sed '[address]a\
new line
'

# 修改: c
sed '[address]c\
new line
'
```

- 转换: `y/inchars/outchars/`

唯一一个处理**单个字符**的命令, **无法限定地址**

- 打印: `p` 模式空间行, `=` 行号, `l` 非打印字符

- 写入: `[address]w file`

- 读取: `[address]r file`. 可配合删除命令, 实现占位套用

- 移动到下一行: `n`

## 多行命令

- `N` 合并下一行内容到当前模式空间

- `D` 删除模式空间中的**第一行**

- `P` 打印模式空间中的**第一行**

## 保持空间命令

`h` 将模式空间复制到保持空间
`H` 将模式空间附加到保持空间
`g` 将保持空间复制到模式空间
`G` 将保持空间附加到模式空间
`x` 交换模式空间和保持空间

## 改变流程

- `!` 排除命令, 如 `$!N` 除了第一行都执行 N

- 分支命令 `[address]b [label]`: address 行会跳转到 label, 没有指定 label 默认跳到脚本结尾
使用 `:label` 指定标签. 可以往后跳, 也可以往前

```sh
echo "This, is, a, test, to, remove, commas." | sed -n '{
:start
s/,//1p
/,/b start
}'
```

- 测试命令 `[address]t [label]`: 根据**替换命令**结果, 成功则跳到 label

```sh
echo "This, is, a, test, to, remove, commas." | sed -n '{
:start
s/,//1p
t start
}'
```

- `q` 退出脚本

# 模式替代

`&` 代表替换命令中匹配的模式: `echo "The cat sleeps in his hat." | sed 's/.at/"&"/g'`

`\数字` 代表**用圆括号**指定的**子模式**, 从 `\1` 开始

```sh
# 这个脚本给每三个数字加逗号
# .*[0-9] 用于寻找用数字结尾的任意长度字符
# [0-9]{3} 寻找若干组三位数字
# t 用于遍历这个数字, 知道放置好所有逗号
# 注意其中的 \ 转移: (, ), {, }
echo "1234567" | sed '{
:start
s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
t start
}'
```

# Snippets

- 删除特定行前的空白行: `sed '/^$/{N ; /pattern/D}' file`

- 跨行替换

注意这个脚本: 带空格的单行命令在 N 前, 带换行符 \n 的多行命令在 N 后.
这样做是为了避免到了最后一行, 因为 N 命令没有下一行可读, 就会终止执行.
如果要匹配的文本刚好在最后一行, 命令不会发现要匹配的数据

```sh
sed '
s/from pattern/to content/
N
s/from\npattern/to\ncontent/
' file
```

- 反序所有行 `sed -n '{1!G ; h ; $p }' file`, 当然也可以直接用 `tac` 命令

- 加倍行间距

```sh
# 技巧的关键在于保持空间的默认值是 **空行**
# /^$/d 用于处理原有的空行
# $! 用于排除最后一行
sed '/^$/d ; $!G' file
```

- 给文件中的行编号

```sh
# = 输出行号, 然后把单独一行的行号和下一行合并
sed '=' file | sed 'N; s/\n/ /'
```

- 打印末尾 5 行, **重点**理解 `6,$D` 的判断效果

```sh
# $q 若为最后一行则退出脚本
# N 否则加入下一行到模式空间
# 6,$D 如果模式空间达到 6 行, 则 D 删除第一行
# b 循环
sed '{
    :start
    $q; N; 6,$D
    b start
}' file
```

- 删除连续空白行

```sh
# /./,/^$/ 匹配任何含有至少一个字符的行
# !d 这种行不会被删除. 那么被删除的肯定就是连续空白行了
sed '/./,/^$/!d' file
```

- 删除开头的空白行

```sh
# /./,$ 从有字符的行到末尾行
# !d 都不会被删除. 那么被删除的肯定就是开头空白行了
sed '/./,$!d' file
```

- 删除结尾空白行

```sh
# 注意大括号可以嵌套
# /^\n*$/ 匹配文本结尾处($)的多个连续(*)空行(^\n)
# $d 如果是最后一行则删除
# N 否则就加入到模式空间
# b start 然后循环
sed '{
    :start
    /^\n*$/{
        $d; N; b start
    }
}' file
```

- 删除 HTML 标签

```sh
# 注意 [^>]* 的使用, 以避免删除标签内的文本
sed 's/<[^>]*>//g' file
```


起始结束标记
    <?php   ?>                              // 标准风格, 推荐
        如果 "?>" 后面就是文档结束, 推荐省略这个 "?>", 否则在某些情况下会报错
    <?      ?>                              // 短风格
    <%      %>                              // asp 风格
    <script language="php">     </script>   // 长风格
    <?= $var ?>                             // 直接输出变量(和 XML 标签有冲突)

语句分隔符 : ";"
    结构定义语句      别加
    功能执行语句      要加

注释
    //                  单行注释
    /*  */              多行注释
    #                   脚本注释
    /**  */             文档注释
    注释要写在代码上面或右面

空白
    两个代码片段之间                        两个空行
    两个类声明之间                         两个空行
    两个函数声明之间                        一个空行
    函数内局部变量声明和第一个语句之间   一个空行
    块注释, 行注释之前                      一个空行

大小写
    变量名, 常量名, 成员变量名区分大小写
    (但是给 define() 传递三个参数 true 会让常量区分大小写)
    函数名, 类名, 成员方法名不区分大小写

变量
    声明 (弱类型)
        $varName = varValue;
        $var1 = $var2 = $var3 = value;
    命名
        不能          以数字开头或使用运算符
        可以          使用关键字

        使用小驼峰命名法
        要有意义
    可变变量
        $var1 = $$var2;
        为避免产生类似 $$var[1] 的困惑, 使用大括号像这样分隔: ${$var[1]} 或 ${$var}[1]
    赋值
        值赋值
            $var1 = 10;
            $var2 = var1;           // 将 var1 的值赋给 var2
            $var1 = 100;            // var1 = 100; var2 = 10(不变)
        引用赋值
            $var1 = 10;
            $var2 = & var1;         // 使用 "&", 将 var1 地址给 var2, 此时 var1 和 var2 都指向同一个地址
            $var1 = 100;            // var1 = 100; var2 = 100
    类型
        标量
            int, integer (4个字节)
                十进制                     $int = 10;
                八进制(以0开头)               $int = 045;
                十六进制(以0x开头)         $int = 0xff;
            bool, boolean
            float, double, real (8个字节)
                科学计数法                   $float = 3.14E-2;
            string
                单引号     $str = 'aaa';
                    不解析变量, 不能使用转义字符(除单引号和转义字符)
                    如非必要, 推荐使用单引号, 因为不用解析变量, 消耗资源较少
                双引号     $str = "aaa";
                    会解析变量(用"{ }"来分隔), 能使用转义字符
                反引号     $str = `aaa`;
                定界符
                    HEREDOC (进行解析, 定界符可以带双引号, 也可以不带, 如 <<<HERE 或 <<<"HERE")
                    NOWDOC (不解析, 定界符必须带单引号, 如 <<<'NOW', 但结尾定界符不用单引号)
                    结尾定界符必须顶行, 并且以 ;+换行 或 换行 结尾

               *String 类型中的单个字符可以用 {} 或 [] 访问, 如
                    $str = 'str';
                    echo $str{0}; // 或 $str[0]
        复合
            array
            object
        特殊
            resource            // 代表要操作的资源(文件, 图片等)本身
            null                // 如果一个变量值为 null, 则代表这个变量不存在, isset() 返回 false
        转换
            强制
                setType($var, type)             // 会改变原变量类型
                (int | integer | bool | boolean | float | double | real | string | binary | array | object | unset)
                                                // 不会改变原变量类型
                intval(), floatval(), strval()  // 等同于上
            自动
                -> BOOLEAN
                    FALSE | 0 | 0.0 | "" | " " | "0" | 空数组 | 空对象 | NULL |   -> FALSE
                    其他                                                  -> TRUE
                -> INT
                    从布尔: FALSE -> 0,  TRUE -> 1
                    从浮点数: 向零取整
                    从字符串: 以合法的数字开始则为这个数字, 否则就是 0
                -> FLOAT
                    从字符串: 以合法的数字开始则为这个数字, 否则就是 0
                    从其他: 先转换为 INT, 再转换为 FLOAT
                -> STRING
                    从布尔: FLASE -> "", TRUE -> "1"
                    从数组: "Array"
                    从对象: "Object"
                    从资源: "Resource id #n"
                    从NULL: ""
                -> ARRAY
                    从任意类型: 一个仅有一个元素的数组
                -> OBJECT
                    从任意类型: 实例化一个内置类 stdClass 的对象
                        NULL: 新的实例为空
                        数组: 键名成为属性名并具有相对应的值
                        其它的值: 名为 scalar 的成员变量将包含该值
    作用域
        局部
            在函数内声明, 只能在自己的函数内部使用
            参数就是局部变量, 这个局部变量可以调用时赋值
        全局
            在函数外声明, 可用于声明语句后的整个脚本
           *如果在函数内使用, 必须用 global 关键字包含之, 或者使用 $GLOBALS 超全局数组
        静态(static)          // 不要和类中的 静态 相混淆
            也是局部的, 但是函数调用完毕, 其值不会丢失
            静态变量可以在同一个函数的多次调用中共用
    相关函数
        isset()                 判断一个变量是否存在
        unset()                 删除一个变量
        empty()                 判断一个变量是否为空
        settype()               强制转换类型
        gettype()               获取变量类型
        get_resource_type() 获取资源类型

        判断是否为某一变量类型
        is_bool()
        is_int(), is_integer(), is_long()
        is_string()
        is_float(), is_double, is_real()
        is_array()
        is_object()
        is_resource()
        is_null

        is_scalar()
        is_numberic()
        is_callable()

        ctype_alnum()
        ctype_alpha()
        ctype_lower()
        ctype_upper()
        ctype_space()
        ctype_punct()
        ctype_cntrl()
        ctype_digit()
        ctype_xdigit()
        ctype_graph()
        ctype_print()

        获取特定类型的值
        intval(),
        doubleval(), floatval(),
        strval()

        其他
        debug_zval_dump()
        get_defined_vars()
        import_request_variables()
        print_r()
        var_dump()
        var_export()
        serialize()
        unserialize()

常量
    定义
        define("constantName", value);
        const(用于类中)
    方法
        defined("constantName")         判断常量是否定义
        constant('constName')           获取常量名为 constName 的常量值
    魔术常量
        __DIR__                         当前文件完整路径
        __FILE__                        当前文件完整路径及文件名
        __NAMESPACE__                   当前命名空间名称
        __CLASS__                       类名
        __METHOD__                      类的方法名
        __FUNCTION__                    函数名
        __LINE__                        当前行号
    常用预定义常量
        PHP_EOL
        PHP_OS
        PHP_VERSION
        DEFAULT_INCLUDE_PATH


*   常量定义后不能改变, 也不能用 unset() 取消
*   常量(和变量不一样)不用理会作用域的限制, 在任何地方都可以使用
    习惯使用大写( 小写也可以 )
    只能包含标量类型

运算符
    算数              +   -   *   /   %   ++  --
    连接              .
    赋值              =   +=  -=  *=  /=  .=  %=
    位                   &   |   ~   ^   <<  >>
    比较|关系|条件        ==  === !=或<>(aka 'pulp fiction')   !== >   <   >=  <=
    逻辑              &&  ||  !   and  or xor
    错误控制            @
    执行              ``
    类型              instanceof
    其他              ? :     =>  ->  ::(aka 'paamayim nekudotayim')  &   $

    使用 && 或 || 会发生短路, 使用 & 或 | 则不会
    使用短路, 也可以控制代码流程
    *&& 与 and, || 与 or 的区别:
        // "||" 的优先级比 "or" 高
        $e = false || true; // $e 被赋值为 (false || true)，结果为 true
        $f = false or true; // $f 被赋值为 false ["=" 的优先级比 "or" 高]

        // "&&" 的优先级比 "and"　高
        $g = true && false; // $g 被赋值为 (true && false)，结果为 false
        $h = true and false; // $h 被赋值为 true ["=" 的优先级比 "and" 高]

流程控制
    顺序结构
    分支(条件|选择)结构
        单路分支
            if() { }
        双路分支
            if() { } else { }
        多路分支
            if() { }... elseif() { }... else { }
            switch(变量) {                // 变量最好只用整形和字符串
                case 变量值:           // 各个 case 都是互斥的, 可以利用此特性简写一些条件判断
                    代码;
                    break;              // 跳出循环. 可以利用 break 匹配多种情况
                case 变量值:
                    代码;             // 如果 case 的语句为空, 则将控制转移到下一个 case, 实现多个 case 共用一段代码
                    break;
                ...
                default:                // 默认执行的语句
                    代码;
            }
            foreach() { }

            if...else...        适用于范围条件
            switch...case       适用于定点值条件
            foreach...          适用于数组
        三目运算符
            boolean ? true_value : false_value

        嵌套分支尽量不要超过五层
    循环结构
        while, do...while       通常用于条件循环
        for                         通常用于计数循环

        嵌套循环尽量不要超过三层
    break                       退出剩余循环
        break 1;                // 默认, 退出一层循环
        break 2;                // 退出两层循环
        以此类推
    continue                    退出本次循环
        continue 1;
        continue 2;
        以此类推
   *declare (directive)     // directive 可为 `tick=N`(每 N 条可计时语句执行一次 register_tick_function()
                            // 注册的 tick hander 函数) 或 encoding(指定这段代码的编码方式)

函数
    定义
        function 函数名(形参, 形参 , ...) {
            函数体
            return 返回值;
        }
    PHP 中的所有函数和类都具有全局作用域, 可以在内部定义外部调用, 反之亦然
    PHP 不支持函数重载, 也不可能取消定义或者重定义已声明的函数
   *带默认值的参数的默认值必须是常量表达式, 不能是诸如变量, 类成员, 或者函数调用等表达式
   *当使用默认参数时, 任何默认参数必须放在任何非默认参数的右侧
   *少传参数会报错(除非少传的是有默认值的参数), 多传参数则不会
    函数不能返回多个值, 但可以通过返回一个数组来得到类似的效果; 总是返回值是一个好习惯
    从函数返回一个引用, 必须在函数声明和指派返回值给一个变量时都使用引用操作符 &
    PHP 支持可变函数的概念. 这意味着如果一个变量名后有圆括号, PHP 将寻找与变量的值同名的函数, 并且尝
    试执行它
   *如果函数未执行完时就递归调用自己, 则当执行完最深一层后, 会层层回退到上一层继续执行完
   *缺省情况下, 函数参数通过值传递(因而即使在函数内部改变参数的值, 它并不会改变函数外部的值).
    如果希望允许函数修改它的参数值，必须通过引用传递参数
    定义可变数量的参数列表
        - 在 5.5 之前, 使用 func_num_args(), func_get_args(), func_get_arg()
        - 在 5.6 之后, 可以使用 `...`, 参数会以数组形式传入函数
        - 为可选的参数赋默认值, 在函数体中做判断

数组
    分类
        索引数组: 索引为整数
        关联数组: 索引为字符串
           *如果你要使用浮点作为键, 使用字符串形式如 '1.5', '1.6'
            否则 php 会向下取整, 这样 1.5 和 1.6 便都为 1
    声明
        直接给元素赋值
            如果不指定索引, 则为之前最大整数索引加一
            如果指定的索引和之前重复, 则视为重新赋值
        使用 array() 函数
       *在 5.4 之后, 可以使用 [] 代替 array()
    访问
        使用 []
       *使用 {}
    遍历
        for() { ... }                                           // 有很多限制
        foreach( $arr as $key => $val ) { ...  }                // 首选
        while( list( $key,$val ) = each( $user ) ) { ... }      // 效率更高

        使用  next() prev() reset() end() current() 可以操作数组指针
    超全局数组变量
        $_GET           // get 方法提交的数据: 会显示在URL中，可以保存书签, 相对不安全, 100个字符限制
        $_POST          // post 方法提交的数据: 变量不会显示在URL中，不可以保存书签, 相对安全, 没有长度限制
       *$_REQUEST       // get, post, cookie 提交的数据: 尽量别去使用该数组
        $_FILE          // post 方法上传文件的信息
        $_COOKIE
        $_SESSION
        $_ENV           // 执行环境相关数据
        $_SERVER        // 服务器和当前脚本环境相关数据
            SERVER_NAME
            SERVER_ADDR
            SERVER_PORT
            DOCUMENT_ROOT

            PHP_SELF
            SCRIPT_FILENAME

            REMOTE_ADDR
            REMOTE_PORT
            REQUEST_URI
            QUERY_STRING
            REQUEST_METHOD
            REQUEST_TIME
            HTTP_REFERER
            HTTP_USER_AGENT
        $GLOBALS        // 所有全局变量, 包括用户自定义的和超全局数组
    数组指针
        数组赋值:
            数组在赋值时, 如果赋值数组的数组指针已经指向了数组末尾则赋值之后赋值数组的数组指针会被重置; 如果在赋值时赋值数组的数组指针没有指向数组末尾而是指向了任何一个有效的数组元素, 那么在赋值之后赋值数组的数组指针是不会被重置的, 而是保留其原来指向的元素
        数组传参:
            如果实参内部指针的位置指向了数组末尾, 那么系统会将形参的内部指针重置, 指向形参数组的第一个单元; 如果实参内部指针的位置不在数组末尾, 即指向了有效的单元, 那么系统会将形参的数组指针位置与实参的数组指针指向值相同的数组单元
        相关函数
            current()
            prev()
            next()
            reset()
            end()
    相关函数
        array_values()
        array_keys()
        in_array()
        array_key_exists()
        array_flip()
        array_reverse()

        count() sizeof()
        array_count_values()
        array_unique()

        array_filter()
        array_walk()
        array_map()

        sort()          rsort()
        ksort()         krsort()
        asort()         arsort()
        natsort()       natcasesort()
        usort()         uasort()        uksort()
        array_multisort()

        array_slice()
        array_splice()
        array_combine()
        array_merge()
        array_intersect()
        array_diff()

        array_push()        array_pop()         // 模拟堆栈操作(先进后出)
        array_shift()       array_unshift()     // 模拟队列(先进先出)
        unset()                                 // 模拟链表(任意存取)

        array_rand()
        shuffle()
        array_sum()
        range()

Date/Time
    三个生成 timestamp 的函数
        time()
        mktime()
        strtotime()
    格式化 timestamp 的函数
        date($format, $timestamp)
        strftime($format, $timestamp)           // recommend
    检查是否一个有效的日期
        checkdate()

执行外部程序
    ``(= shell_exec())
    system()
    exec()
    passthru()
    virtual()

面向对象
    类
        声明
            class 类名 // `stdClass` 和 `__PHP_Incomplete_Class` 为 PHP 保留字
            {
                成员属性
                    // 定义成员属性必须使用 $, 访问成员属性不用使用 $ 符号
                   *// 属性中的变量可以初始化, 但是初始化的值必须是常数
                成员方法
            }
        命名
            大驼峰命名法
            一个文件包含一个类, 文件名以 类名.class.php 命名
        访问控制关键字
            public : 可以在任何地方被访问
            protected : 可以被其所在类及其子类和父类访问
            private : 只能被其所在类访问
        继承( PHP 是单继承的 )
            extends 关键字
            子类中声明和父类相同的方法名, 会覆盖父类的方法(PHP 意义上的重载), 如果要在子类中访问父类中被覆盖的方法, 可以使用 parent::方法名()

            final 关键字
            父类中的方法被声明为final, 则子类无法覆盖该方法
            如果一个类被声明为final, 则不能被继承
        static 关键字
           *定义静态(类)属性和方法, 使用 :: 访问      // 定义和访问静态属性需要使用 $ 符号
           *静态方法访问方式: 1. 类::方法    2. 实例->方法
           *静态属性访问方式: 1. 类::属性    2. 实例::$属性
            存储于数据段中, 用于让所有该类的对象共享该成员
            不用实例化类即可访问, 所以 $this(可以使用 self) 在静态方法中不可用, 也不能在静态方法中访问非静态成员
            不能通过一个对象来访问其中的静态成员(静态方法除外)
           *对静态属性的改变, 会反映到所有父类和子类中
            如果所有类的对象的属性值要保持同一, 或确保方法不会使用非静态属性, 则可以声明为静态成员
            static 关键字应放在 3P 后面
           *你可以把静态属性初始化为整型或数组, 但不能指向另一个变量或函数返回值，也不能指向一个对象
        const
           *声明类常量, 定义和使用时都不需要 $ 符号, 使用 <类名>:: 访问
            与静态属性的不同: 静态属性可以修改, 但类常量不可以
    抽象类(由 abstract 定义, extends 继承)
        至少要包含一个抽象方法(由 abstract 修饰, 没有方法体, 用 ; 结束), 其他和一般类相同
        不能直接被实例化, 必须先继承该抽象类, 然后再实例化子类
        子类必须实现抽象类中的所有抽象方法, 这些方法的可见性必须和抽象类中一样或者更为宽松
        abstract 关键字应该放到 3P 前面
    接口( 由 interface 定义, extends 继承, implements 实现)
        指定某个类必须实现哪些方法, 但其中定义所有的方法都是空的, 而且必须为 public
       *不能在接口中声明成员属性, 但可以声明接口常量
        一个类可以实现多个接口( , 分开), 弥补单继承缺点
        实现多个接口时, 接口中的方法不能有重名
    对象
        实例化
            $变量名 = new 类名()
        成员访问
            在对象外: -> 操作符
            在对象内: $this 伪变量
        序列化
            使用函数 serialize() 和 unserialize 将一个对象转换为一个包含字节流的字符串或反之
            用于将对象长时间保存在数据库或文件中, 或者在多个 php 文件间传输时
        比较
                                                    ==              ===
            reference :                                 true            true
            instances with matching attributes  true            false
            instances with differenct attributes    false           false
    魔术方法 ( 不同时机自动调用以完成特定功能的系统定义方法 )
        构造析构
            __construct() : 创建新对象时先自动调用此方法, 适合在使用对象之前的初始化操作
            __destruct() : 某个对象的所有引用都被删除或者当对象被显式销毁时执行, 一般用来放置关闭资源等等收尾工作
       *重载方法( 所有的重载方法都必须被声明为public, 这些魔术方法的参数都不能通过引用传递 )
            __set(string $name , mixed $value )
                给未定义或不可见的变量赋值时被调用
            __get(string $name )
                读取未定义或不可见的变量的值时被调用
            __isset(string $name )
                当对未定义或不可见的变量调用isset() 或 empty() 时被调用
            __unset(string $name )
                对未定义或不可见的变量调用unset()时被调用

            __call(string $name , array $arguments )
                调用一个未定义或不可见方法时被调用, 用于错误处理
            __callStatic(string $name , array $arguments )
                在静态方法中调用一个未定义或不可见的方法时被调用

        __clone() : 当使用 clone 复制对象时被调用, 用于对副本初始化($this 代表副本, $that 代表原本)操作
        __toString() : 当直接以字符串形式输出对象时被调用
        __sleep() : 当对象被序列化时被调用, 常用于提交未提交的数据等类似的清理操作或部分序列化
        必须返回一个包含所需序列化的对象属性数组
        __wakeup() : 当对象被反序列化时被调用, 用于重新建立数据库连接等初始化操作
        __invoke()
        __setState()

        __autoload( $class_name )
            试图使用尚未被定义的类时自动调用, 这是唯一一个在类外部使用的魔术方法
    Trait
        Trait 为了减少单继承语言的限制, 使开发人员能够自由地在不同层次结构内独立的类中复用方法集
        通过 use 关键字在类定义中引入 Trait, 优先顺序是来自当前类的成员覆盖了 Trait 的方法, 而 Trait 则覆盖了被继承的方法
        如果两个 Trait 都插入了一个同名的方法, 如果没有明确解决冲突将会产生一个致命错误
        使用 insteadof 操作符来明确指定使用冲突方法中的哪一个,   使用 as 将冲突方法以别名方式引入
        也可同时用 use 指定引入时的方法可见性(3P)
        其它 Trait 也能够使用 Trait
        为了对使用的类施加强制要求, Trait 支持抽象方法的使用
        Traits 可以定义静态成员静态方法
        如果 trait 定义了一个属性, 那类将不能定义同样名称的属性, 否则会产生一个错误
    相关函数
        get_declared_classes()
        class_exist()
        get_class_methods()
        method_exists()
        get_class()
        is_a()
        get_class_vars()
        property_exists()
        get_parent_class()
        is_subclass_of()

引用(可理解为别名, 删除别名并不会删除别名指向的变量)
    变量的引用传递
        $var = &$var2
        所有对 $var 的更改将反映到 $var2
    函数的引用传递
        function fun(&$var) {
            所有对 $var 的更改将反映到 $var 指向的变量         // 也可以用全局变量实现
        }
    函数的引用返回
        function &fun(){
            return ...
        }
       *此时, 如果要将函数返回作为引用赋值, 必须在赋值时加&, 如 $var = &fun();
        函数名前面的 & 和 赋值时的 & 两者缺一不可
    对象的引用
        默认即为引用传递, 如果不想用引用, 使用 clone 关键字

    用途
        如果程序比较大, 引用同一个对象的变量比较多并且希望用完该对象后手工清除它, 建议用 "&" 方式, 然后用 $var = null 的方式清除;
        对于大数组的传递, 建议用 "&" 方式, 毕竟节省内存空间使用

命名空间
    只有三种类型的代码受命名空间的影响: 类, 函数和常量

    声明
        使用 namespace 关键字
        必须在其他所有代码之前(除 declare 语句)
        同一个命名空间可以定义在多个文件中
        将全局的非命名空间中的代码与命名空间中的代码组合在一起, 只能使用大括号形式的语法. 全局代码必须用一个不带名称的 namespace 语句加上大括号括起来
        除了开始的 declare 语句外, 命名空间的括号外不得有任何 PHP 代码

    三种
        非限定名, 如 foo
        限定名, 如 foo\bar
        完全限定名, 如 \foo\bar

    别名/导入
        使用 use/as 关键字
        只支持命名空间和类的别名, 不支持函数和常亮
        一行可以使用多个 use/as 语句, 使用 ',' 号分割

关键字
    abstract    and          array()     as          break
    case        catch        class       clone       const
    continue    declare      default     do          else
    elseif      enddeclare   endfor      endforeach  endif
    endswitch   endwhile     extends     final       for
    foreach     function     global      goto        if
    implements  interface    instanceof  namespace   new
    or          private      protected   public      static
    switch      throw        try         use         var
    while       xor

=============== 杂项 ===============
form action为空时,默认是本页面php代码执行
setsession()和setcookie()必须位于<html>标签之前

基于 Unix 的系统使用 \n 作为行结束字符, 基于 Windows 的系统使用 \r\n 作为行结束字符, 基于 Macintosh 的系统使用 \r 作为行结束字符

urlencode() VS rawurlencode()
    两个都是把除  -_.  之外的所有非字母数字字符都将被替换成百分号 (%) 后跟两位十六进制数, 唯一不同是 urlencode 把空格替换成 +, 而 rawurlencode 把空格替换成 %20
    rawurlencode 兼容性更强
    urlencode 适合用于编码 url 路径部分(?之前); rawurlencode 适合编码请求字符串部分

htmlspecialchars() VS htmlentities()
    htmlspecialchars 将 < > " & 转换为对应的实体 (&lt; &gt; &amp; &quot;)
    htmlentities() 将所有有对应实体的字符转换为对应实体

strip_tags() VS nl2br()

Hash 算法
    MD5     // not recommended
    SHA-1       // theory say could be hacked
    SHA-2(SHA-256, SHA-512)
    Whirlpool, Tiger,AES
    Blowfish    // recommended
Hash 函数
    md5()
    sha1()
    hash()
    crypt()
    salt()

- 除非打开 output buffering, header() 之前不能有任何输出
- 可以在 php.ini 里打开 output buffering, 也可以用 ob_start() 在页面级打开( 参见 ob_end_flush(),
  ob_get_contents(), ob_end_clean() )
- header() 和 ob_start() 之前不能有任何输出
- One mistake that is easy to make with the Location header is not calling exit directly afterwards (you
  may not always want to do this, but usually you do). The reason this is a mistake is that the PHP code of
  the page continues to execute even though the user has gone to a new location. In the best case, this
  uses system resources unnecessarily. In the worst case, you may perform tasks that you never meant to
- you must never trust request headers for information that is important to the security of your site

epoch time === unix timestamp

Cache Strategy
    1. Code level (variable, static variable)
        Pro: independent of any external extensions
        Con: not shared between PHP processes; difficult to invalidate
    2. OpCode Cache (APC)
        Pro: persist between multiple requests
        Con: not distributed
    3. Memory Cache (Memcached, Redis)
        Pro: distributed;
        Con: slower than APC
    4. In-memory database tables (MySql Memory engine)
    5. File/Output Cache (Ob, serialize)
    6. Query cache
    7. Apache cache


=============== Error/Exception ===============
Set in
    php.ini
    httpd.conf
    htaccess
    run time
Level
    1       E_ERROR
    2       E_WARNING
    4       E_PARSE
    8       E_NOTICE
    16      E_CORE_ERROR
    32      E_CORE_WARNING
    256     E_USER_ERROR
    512     E_USER_WARNING
    1024                 E_USER_NOTICE
    2048                 E_STRICT
    4096                 E_RECOVERABLE_ERROR
    8191                 E_ALL
general place shoud considering error handling:
    connect to database
    using global variable
    open a file
    validate user input
    division by zero
You can chosse to
    display them        suit for development
        display_errors = on(default is off)
        error_reporting()(default is all except E_NOTICE and E_STRICT)
    log them        suit for production
        log_errors = on
        error_log = /path/to/filename | error_log = syslog
        error_log()
    ignore them
        @
    act on them
        see below
Ways to handle
    1. die/exit
    2. custom error handling function:set_error_handler(), trigger_error()
        error_reporting( E_ERROR );
        function handleError($errno, $errstr,$error_file,$error_line)
        {
         echo "<b>Error:</b> [$errno] $errstr - $error_file:$error_line";
         echo "<br />";
         echo "Terminating PHP Script";
         die();
        }
        //set error handler
        set_error_handler("handleError");
        //trigger error
        myFunction();
    3. handle exception:throw..try..catch
        Exception::
            getMessage()
            getCode()
            getFile()
            getLine()
            getTrace()
            getTraceAsString()
    4. custom exception handling function:
        function exception_handler($exception) {
          echo "Uncaught exception: " , $exception->getMessage(), "\n";
        }
        set_exception_handler('exception_handler');
        throw new Exception('Uncaught Exception');
        echo "Not Executed\n";
Function reference
    debug_backtrace                Generates a backtrace
    debug_print_backtrace          Prints a backtrace
    error_get_last                 Get the last occurred error
    error_log                      Send an error message somewhere
    error_reporting                Sets which PHP errors are reported
    restore_error_handler          Restores the previous error handler function
    restore_exception_handler      Restores the previously defined exception handler function
    set_error_handler              Sets a user-defined error handler function
    set_exception_handler          Sets a user-defined exception handler function
    trigger_error                  Generates a user-level error/warning/notice message
    user_error                     Alias of trigger_error

=============== Coding Standard ===============
- 4 *space*, not tab
- Line at most 75-85 characters
- One space between control keywords(if,else,for,while,switch...)
- No space between function name,opening parenthesis and the first parameter; space between commas and each parameter; no space between the last parameter and closing parenthesis and the semicolon
- Always use curly braces
- Always attempt to return a meaningful value from a function if one is appropriate

=============== Coodie ===============
// if $a is false then set it to 'default'
$a = $a || 'default';

// you can do things with += and + like this:
$a += $a + 1;

function $increment(){
    static $var = 0;
    $var ++;
    return $var;
}
$a =& increment();
increment()
$a ++;
echo $a;

/**
 * test if $date is a valid date string
 * @return {boolean}
 */
function validateDate($date) {
    return $date == date('Y-m-d', strtotime($date));
}

while (list($option, $value) = each($products)){

}

$ary = array('key1' => 'value1',
             'key2' => 'value2',
             ...);

$var = explode(',', $ary)[idx];

Random String
    1.substr(md5(rand()), 0, 20)."\r\n"
    2.substr(str_shuffle("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"), 0, 30)

return $this at the end of method will make this method chainable

set utf8 header
    header('Content-Type: text/html; charset=utf-8');

$ary1 = array(
    array(
        'sn' => '123',
        'name' => 'whatever',
        ),
    array(
        'sn' => '234',
        'name' => 'whatever',
        ),
    );
$ary2 = array(
    array(
        'sn' => '234',
        'gender' => 'female',
        ),
    array(
        'sn' => '123',
        'gender' => 'male',
        ),
    );

$res = [];
foreach (array_merge($ary1, $ary2) as $a) {
    $res[$a['sn']] = (isset($res[$a['sn']])) ? array_merge($res[$a['sn']], $a) : $a;
}

=============== Idiom ===============
declare variable before using them
use spl_autoload_register(), not autoload()
?typehint everywhere, user assertions for scalars
use === instead of ==
use bracket to make your operator precedence more clear

====================== TinyThings =======================
array_search() only return key name when the *whole* value match the needle
foreach 开始执行时, 数组内部的指针会自动指向第一个单元, 不需要手动 reset
shuffle() 将删除原有的键名, 赋与新的键名, 而不是仅仅将键名重新排序
you can't remove elements with array_walk()
json_encode() considers an array with non-sequential non-numeric keys as an object
json_decode() can convert object json str to assoc array if you pass the second param as true to it
you can convert object to assoc array simply by doing type casting (object)


@new
* In json object, keys must be quoted
* In json, quote mark must be " , not '



// @add
====================== Confusion =======================
1. 子类会继承父类的静态属性和方法吗?
A. NO
2. 子类会继承父类的私有属性和方法吗?
A. NO
3. null/none-zero is ?
A. int(0)
4. */0 is ?
A. bool(false)
5. is array(array()) empty?
A. no, it contain a empty array, so it's not empty!
6. is `!emtpy($var)` enough or have to do `isset($var) && !empty($var)`
A. `!emtpy($var)` is enough.
   `!empty($var)` is semantically equivalent to `(isset($var) && $var)`

====================== Advised: =======================
1. you don't have keys named 'foo1' and 'foo2' - use an array
2. Structuring your data right in the first place can help a lot
3. When there's no `else`, I prefer to explicitly halt at the top, so people don't have to scan ahead to see whether there's an else clause

====================== Learned =======================
1. SQL 和 数据结构 和 设计模式 应该深入掌握
2. 如果明明只有一个文件定义了某个函数, 却报 `can not redecalre function` 错误, 那么肯定是 include/require
   了多次这个文件
3. 如果彻底找不到某个变量在哪里定义的, 想想是不是 extract() 生成的. 想想是不是由某个 handler 函数生成/改变的. 想想是不是可变变量生成的. 想想是不是 $GLOBAL[$foo] 生成的
4. 如果想知道某个变量是干什么用的, 就去看它在哪里定义, 在哪里怎么使用的
5. 如果想知道一个系统的流程是怎么走的, 就去看传过去的 get, post(command, action, flag, type...)
   是如何标识不同的请求, 转向不同的处理的
6. 各种字符(单引号, 双引号, 反斜杠)的源(db, html, js, eval()...)的转换非常容易引起问题
7. after a query, always check if query result available before using it
8. Use utf8_encode() and utf8_decode() to work with texts in ISO-8859-1 encoding or Iconv for other encodings
9. strpos() 可能返回位置 0, 所以不要直接用 strpos() 的结果作为判断条件
10. if a function is for testing, use `is...` as its function name like: isBigger, isGood, isValidUTF8String
11. if you directly echoing html out in php, remember to set the correct encoding, like:
        exit('<script charset="utf-8">alert()</script>');
12. if you echoed something out before, then you can't redirect using header() after then
13. when debugging `header already sent` error, remember, even whitespace after ?> tag can be the problem
14. when making a recursive function, remember there must be two thing:1. a base case to return, 2. an accumulator to save result
15. use var_dump() to get error reporting's bitmask value
16. recreate session id without manipulation of cookie:
    http://www.hiteshagrawal.com/php/generate-unique-sessionid-in-php/
17. 写 api 时, 传来的参数检查对于程序运行和 debug 都非常重要, 不要忽略
18. in_array('15445{1}2488', array(15445)); will result in true, becuase '15445{1}2488' is first converted to integer 15445
19. 进入 php cli interactive 模式: `php -a`
20. 在循环中, 要特别注意某个变量是不是要在循环完后 unset, 以免影响下次循环
21. be very careful when you run `rm -rf ...` in php!
22. cookie data, like any user input date, can be harmful and you should sanitize it
23. 如果一个域名没有注册, 但是你知道服务器的 ip, 此时想访问指定用户 user 的 web 目录, 可以使用这种格式:
        http://1.2.3.4/~user/       (会自动进入 web 目录, 所以不用再额外指定 www)
24. Learning SPL is the key to true mastery of PHP
25. BECAUSE functions like substr() and strtoupper() expect precisely one byte per character, and will corrupt a multibyte string. Instead, you should use the multibyte equivalents of these functions, such as mb_strtoupper() instead of strtoupper(), mb_ereg_match() rather than ereg_match(), and mb_strlen() rather than strlen(). The parameters required for these functions are the same as their original, except that most accept an optional extra parameter to force specific encoding. see php.ini:mbstring.func_overload
26. `$a <= $b <= $c` won't don what you expected to do, use `$a <= $b && $b <= $c` instead
27. 禁用 `register_globals`, 禁用 `magic_quotes`
28. user isset() and is_array() when tring to use a variable as array , like `echo $ary[1]` or `foreach($notAry as ...)`
29. 如果 IE 展示中文下载名为乱码, 试试将名字 urlencode() 一下

====================== Quote in IRC =======================
rager:
- honestly, there's rarely a reason you must use global/static
- once things are no longer dependent on the data you hand them but also data they have to retrieve
  from global state, you cannot actually reliably reason about application behavior
- but you can often use global state as a short-cut to getting things done, especially when you have
  architectural problems that there isn't time to fix

Unopoo:
- if I don't define the child class' own constructor, it will inherite its parent class, and when instantiating the *child* class, it find its parent's constructor, so, $this is its parent then.

- (function(a){code}(A)) in js means pass A as a and run code once only

__adrian:
- It's *not* a code smell if strategy class need context class' info, it *is* if it goes out and tries to get that info on its

Sharaal:
- vcs focused on the code, deploy focused to use the code with an environment to have a running system

laszlof:
- CGI is a method of passing HTTP requests off to various processors(mod_php, php-fpm etc.)

Naktibalda:
- busy sites don't use gc

fleetfox:
- if you don't want to use whole framework, use composer and packagist to get components you want
- you don't use sessions for apis in general, rest api should not be statefull
- unless it's factory method or namespacing for "pure" function there is little reason to make something static

sorabji:
- doing an sql query in a recursive function is questionable

pppingme:
- the best ways to do it is to either define your host name as a varialbe, and reference that variable in your code, or make everythign relative (so full url's are never used)

- Unopoo: can I do a ? : operation when concatenating a string?
- AndreasLutro: yes, but put it in parenthesis or you're going to run into issues of operator precedence

Alphos:
- the way php handles functions usually is to find all function definitions, create the corresponding functions, then run the rest of the script. when you define a function conditionnally, you pull it out of that first step, and it gets defined IF the condition is true WHEN it reaches the condition ; it is then unavailable for anything that calls it before it's defined
- never to define functions conditionally

TML-prv:
-  just avoid changing variables in-place

<UniFreak> should I make it a rule that always put api call in try catch block?
<AcidReign> UniFreak: no, you try/catch for a reason
<fleetfox> UniFreak: only if you want to handle the exception

=============== Understand ===============
Interface
    - is a special type of entity in Object Oriented Programming (OOP) which defines a *contract*
      between a *client* and a *server* class
    - When you want to name an interface you must think of the *client* and forget about the
      implementation
Setter & Getter
    - with setter & getter, it allows for divergence between data usage and data source,  for filters and
      validators etc

=============== Methodology ===============
You must always consider your business carefully
Be completely and utterly paranoid
All web application are vulnerable
Trust nobody and nothing(including ourown database)
Assuming everyone or thing is tring to breach your app
Validat input, Escape output

Set `register_globals` off, or only use variables that you explicitly set yourself
Set `error_reporting` to 0 in production env
Don't use any default username & password
Don't be predictable(use admin/ folder)
Disable `directory listing`
Place a `index.html` file in every folder
Place important file(database.php) outside of web folder
Threefold protection of admin area:
    use turing test when login(captcha)
    disable login if fail repeately
    log IP both failed and succeed, spot those suspicous IP and block it
Database protection
    least privilege principle(minimize damage even database got hacked)
    implement false deletion, and disable all user's deletion privilege
Use `disable_functions` in php.ini to disable evil functions, like
    eval(), ini_set(), exec(), fopen(), popen(), passthru(), readfile()
    file(), shell_exec(), system() and etc
Enable `safe_mode` if you can
Properly setting character encodings at all stages of the process and specifying character encoding for functions where possible

Input validation
    when using 3rd party validator, know that
        - the 3rd party self maybe unsafe, check them if you use them
        - the may not contain our web-app-specific required validation
    be wary of context(html? url? db?)
    never blacklist, only whitelist
    wherever you must filter, filter *before* validation
    never trust external validation control(such as html form) but do monitor breaches
    prefer strict comparison
    use manual type conversion where input/output might be strings
    use ssl/tls to prevent MITM attack when make api request, and **do enable `verify_peer`**

    including
        data type check
        allowed characters check
        format check
        limit check
        presence check
        verification check(identical password)
        logic check(error control)
        resource existence check

Injection attack
    XSS(cross-site scripting)
    SQL injeciton
    Header injection
    Log injection
    Full-path injection
   *UI Redress
    ...and so on

    SQL injection
        ```php
        // - validation
        // - escape
        // - prepared statement
        // - enforce least privilege principle
        //    - never use root for web application
        //    - only give essential privilege to user
        //    - seperate roles of read & write
        if(ctype_digit($_POST['id']) && is_int($_POST['id'])) {
            $validatedId = $_POST['id'];
            $pdo = new PDO('mysql:store.db');
            $stmt = $pdo->prepare('SELECT * FROM transactions WHERE user_id = :id');
            $stmt->bindParam(':id', $validatedId, PDO::PARAM_INT);
            $stmt->execute();
        } else {
            // reject id value and report error to user
        }
        ```
    Code injection
        inject code into server side is code injection
        inject code into client side(javascript) is XSS
        when code injection occurs as the result of including an external resource, it's RFI(remote file inclusion)

        common cause
            - input validation failure
            - failure to secure source code
            - failure to check third party lib
            - server misconfiguration allow non-PHP file to be interpretered
        watch out when
            - include, require
            - eval()
            - use preg_replace with `e` modifier

#Goal
- 让同事认识并理解 grasp&solid， 及其重要性
- 探讨应用到工作中的可能性

#GRASP
- RDD --> 职责 --> GRASP
- 名称 & 解释
- GRASP vs 其他模式
    + 模式的作用&问题(太多!) --> GRASP!
    + GRASP->SOLID->GOF->架构模式->...
    + GRASP: 原则 or 模式?
- 模式列表
- Creator
- Information Expert
- Low Coupling
- Controller
- High Cohesion
- Polymorphism
- Pure Fabrication
- Indirection
- Protected Variation

#SOLID

##软件臭味

#闻起来

- 僵化性: 它比我想象的要复杂!
- 脆弱性: 谁知道还有这儿的事儿!
- 牢固性: 难以分离重用
- 粘滞性: 这是最快的方式!
    + 软件
    + 环境
- 不必要的复杂性: YAGNI!
- 不必要的重复: 看起来很像, 改起来费死劲 --> 忽略了抽象
- 晦涩性: 这是我写的? --> 站在阅读者角度

#原因

- 需求变更
- 设计缺陷

#应对

- 接受事实: 应对需求变更是我们的职责
- 抓住变更机会, 改进设计应对**此类**变更 --> 问题: 排期
- 改进设计: 设计原则: SOLID & 设计模式(later)
- 不要说稍后, 也不用预先设计, Just in time

##SOLID

- 名称

#SRP

- 就一个类而言, 仅有一个引起它变化的原因
- 示例: 业务操作通过持久化动作来实现
    + 客户 A 必须要包含不必要的针对客户 B 的职责代码
    + 客户 B 改变 -> 服务类改变 -> 客户 A 也要被迫改变
- 相关: 测试驱动开发, FACADE, PROXY
- 问题: 如何识别职责并确定是否应该分开 --> 依赖于应用的变化方式

#OCP

- 软件实体应该是可以扩展的, 但是不可以修改的
- 目的: 在不腐败设计的情况下扩展行为(通过增加新代码, 而非改动现有代码)
- 实现: **关键是抽象**
    + 抽象基类: closed for modification
    + 实现类: open for extension
- 示例: 增加新资方/新信审入口 in credit&erp
    + 到处找 if/else
    + 有些甚至连 if/else 都没有
- 相关: STRATEGY, TEMPLATE METHOD, 表驱动法
- 问题: 导致变化的原因不止一个维度, 如何选择应当对哪个维度封闭?
    + 经验 -> 既要熟知设计, 又要熟知领域 -> 常失败
    + fool me once, shame on you; fool me twice, shame on me
    + -> 刺激变化
        * 测试
        * 短周期迭代开发
        * 及早开发特性
        * 频繁发布
        * ...


#LSP

- 子类型必须能够替换掉他们的基类型
- 目的: 创建正确的继承层次, 保证 OCP
- 示例: is-a 经典坑: Rectangle&Square
    + 浪费的成员变量(示例很多时会形成性能问题) -> 暂不考虑
    + 不合适的 Square 操作: 设置宽/高分开 -> 代码修复
    + 真: 自相容不代表和用户程序相容
    + 契约不再有效, 没有能被信任的服务
    + 导致 RTTI(也是违反 LSP 的明显症状), 必须单独考虑每个子类, 增加复杂性
    + 违反 OCP
- 实现
    + is-a 应该从行为方式角度看
    + 基于契约设计(DBC):前置后置:宽进严出|弱进强出
    + 单元测试
    + 父子变兄弟 | 父子变子父
- 相关: OCP: 正是子类的可替换性, 才使得使用基类类型的客户无需修改即可被扩展

#SRP

- 含义:
- 原因 & 违反恶果

#SRP

- 含义:
- 原因 & 违反恶果


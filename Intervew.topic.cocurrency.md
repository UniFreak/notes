# 并发: 多个会话访问共享数据

并发问题:
- 本质: 更新丢失, 不一致读

离线并发: 跨事务的数据处理中管理好并发问题

执行语境: 
- 请求: 外部环境对软件的单个调用
- 会话: 客户端和服务器端长时间交互 (从登陆到退出)
- 针对数据库 - 事务: 让客户端将多个请求当做单个请求看待

方案要求: 正确性, 灵活性
- 隔离: 每片数据只能被一个执行单元访问 -> 在每个隔离区尽可能完成多的任务
- 不变性: 识别不变数据, 不用为之考虑并发问题从而广泛共享

还是有某些无法隔离的可变数据:
- 乐观锁 (冲突检测)
    将冲突检测建立在数据的某种版本标记上 (时间戳 / 顺序计数器)
    - 检测更新丢失: 核对更新数据和共享数据的版本是否一致
    - 检测不一致读: 检测读取的数据和共享数据的版本是否一致
- 悲观锁 (冲突避免)
    读: 获取读锁 - 共享锁  可加多个, 但只要有读锁, 无法获取写锁
    写: 获取写锁 - 排它锁  只要有一个写锁, 无法获取任何锁
    死锁
    - 检测并处理: 使用软件检测, 并选出牺牲者 / 超时控制
    - 防止: 强制一次性获取所有可能需要的锁 / 规定获取锁的顺序
    - 混用以上方式
选择标准: 冲突的频率和严重性
- 频率少, 不严重 -> 乐观
- 频率多, 严重 -> 悲观

# 事务: 有边界的的工作序列, 据有 ACID 属性

- Atomicity 原子性: 要么全部完成, 要么什么也不做
- Consistency 一致性: 相关资源在其中都保持一致
- Isolation 隔离性: 提交之前对于其他事务不可见
- Durability 持久性: 提交之后的结果是持久的

事务资源: 可以进行事务处理的任何事物
请求事务: 在请求开始启动, 在请求结束提交
长事务: 跨越多个请求
延迟事务: 事务外处理读取, 只在修改数据时启动事务
锁升级: 数据库无法处理太多行锁, 只能锁住整张表
系统事务: 由关系数据库和事务检视器所支持的
业务事务: 登录, 选择账户, 填写账单, 点击提交...

## 让系统事务支持 ACID -> SQL 标准 4 种隔离级别:

    级别              脏读  不可重复度   幻读
    ---------------------------------------
    读未提交           Y        Y       Y
    读已提交           N        Y       Y 
    可重复读           N        N       Y
    可串行化           N        N       N

## 让业务事务支持 ACID

- 在单个系统事务中完成整个业务事务
    常需要多次请求, 变成长事务, 多数事务系统不能有效支持长事务
    应用失去伸缩性, 长事务使数据库称为主要瓶颈
    以后改写成短事务也很复杂
- 自己为跨系统事务的业务事务提供 ACID 支持 <- 离线并发问题
    AD: 在业务事务周期中维持修改集, 业务事务提交时开启一个系统事务
    IC: 单个事务中: 满足业务规则 / 多个事务中: 一个会话不会破坏其他会话的工作

离线并发控制模式 (last resort)
- 乐观离线锁 
- 悲观离线锁
- 粗粒度锁
- 隐含锁

# 应用服务器并发: 不涉及事务

每会话一进程 --资源消耗--> 进程池
每会话一线程
# 概论

NOTE:
- i 从 1 开始...
- 命名: ListSize -> listSize
- 注释: p.
- 书中错误: @err
- main 简单的用例测试
- dump
- *Test.c

TODO:
- test.sh: test.sh *, test LinkStack...


Learn:
- malloc, 指针, NULL 对于初始化的作用

## 数据结构

好的算法必须建立在研究数据的特性及数据之间存在的关系的基础之上.

**数据结构**一般包括三方面内容
- 数据之间的逻辑 (或抽象) 关系, 即**逻辑结构**. 包括*
    + **线性结构** (如线性表, 栈, 队列)
    + **非线性结构** (如树, 图)
- 数据元素及其关系在计算机内的存储方式, 即**存储结构(物理结构)**
    + **顺序存储**: 逻辑上相邻的点在物理位置上也相邻. 通常用于线性结构数据, 但非线性结构也可以通过线性化方法用顺序存储
    + **链接存储**: 元素间的关系用附加的指针域表示, 物理位置不一定连续
    + **索引存储**: 存储元素的通史, 附加建立一份索引表
    + **散列存储**: 根据元素关键字直接计算出元素的存储地址
- 数据的**运算**, 如增删改查等

    运算的具体实现是在存储结构上进行的, 因此在逻辑结构上定义的运算, 只要给出运算的功能是 "做什么", 至于 "怎么做" 等实现细节, 只有待确定了存储结构之后才能考虑

    对于不同问题, 需要的运算可能不同.

    复杂的运算, 可用基本运算的组合来实现.


数据结构 VS 数据类型 VS 抽象数据类型 (ADT)
- 数据类型可看作是程序设计语言中已实现的数据结构
- 抽象数据类型可看做是描述问题的模型, 它独立于具体实现. 等价于在数据的逻辑结构以及在逻辑结构上定义的抽象操作

## 算法

**算法**是对问题求解步骤的描述. 必须满足以下**五个准则**:
1. 给定输入
2. 至少有一个或多个输出
3. 有穷: 每个步骤的执行次数必须有限, 且在又穷时间内完成
4. 确定: 每个步骤的含义明确无二义
5. 可行: 每个步骤都可以通过有限次的基本运算来实现

算法不依赖于计算机程序语言, 可用自然语言, 程序语言, 约定的符号语言等描述.

对算法的评价和**分析**包括:
- 最主要的是**时间复杂性**, 即算法耗费的时间
- **空间复杂性**, 即算法耗费的存储空间
- 可读性和可操作性

# 线性表

定义: 由 n 个数据元素组成的有限序列. 数据元素的个数 n 为表的长度. 当 n 为 0 时称为空表.

逻辑特征
- 有且仅有一个开始元素, 它没有前趋, 仅有一个直接后继
- 有且仅有一个终端元素, 它没有后继, 仅有一个直接前趋
- 其余元素称为内部元素, 它们都有且仅有一个直接前趋和一个直接后继
- 这种相邻关系又称为线性关系, 可见线性表是一种典型的线性结构


## 顺序存储

使用顺序存储的线性表称为**顺序表**. 它的特点是:
- 只要知道基地址和每个元素占用的单元数, 就可求出任一元素的地址
- 任意元素都可随机存取 (存取某个位置的元素不必事先存取其前一个元素), 顺序表是一种随机存取结构

缺点: 需要移动大量元素 -> 链式存储

通常用数组来描述顺序表

基本运算: @see SeqList.c

## 链式存储

缺点:
链表的结点不可以随机存取

链式存储不仅可以用来表示线性表, 还可以用来表示各种非线性的数据结构.

### 单链表

链表: 元素由两部分组成:
数据域: 存储数据元素
指针域: 存储直接后继地址

用这种存储方式表示的线性表称为链表. 每个结点只包含一个指针域, 因此又称为单链表.
终端结点的指针域为空, 即 NULL
设立头指针指向开始结点.
如果链表中一个结点都没有, 则为空链表. 此时头指针为 NULL

一个单链表可由头指针唯一确定, 因此单链表可以用头指针的名字来命名.
为方便操作, 可以在开始结点之前附加一个头结点.

存取第 i 个结点时, 必须从表头结点开始搜索, 所以链表结构是非随机存取存储结构. 若链表带头结点时, 就应特别注意头结点和表头结点 (即开始结点) 的区别.

基本运算: @see LinkList.c

### 循环链表

**循环链表**是链式存储的另一种形式, 它的特点
- 单链表中最后一个结点的指针域不为空, 而是指向链表的头结点, 是整个链表构成一个环
- 从表中任一结点开始都可以访问表中的其他结点

可有单循环链表, 还可以有多重链的循环链表

它的结点类型与单链表完全相同, 在操作上也与单链表基本一致, 差别仅在于算法中循环结束判断条件不再是 p 或 p->next 是否为空, 而是他们是否等于头指针.


@see CycleLinkList.c

### 双向链表

向单向链表的结点类型中, 增加一个指向其直接前趋的指针域, 这样形成的链表为**双向链表**.

双向链表可以从表中快速确定一个结点的直接前趋.

@see DLinkList.c

双链表中增设一个头结点, 将尾结点和头结点链接起来就构成了**双向循环链表**

# 栈和队列

## 栈

**栈**是一种限定在表的一端进行插入和删除运算的线性表. 将插入, 删除的一端称为栈顶, 另一端称为栈底. 栈又称为后进先出 (LIFO) 表. 插入称为**进栈**, 删除称为**退栈**.

栈的顺序存储结构称为**顺序栈**, 类似于顺序表, 顺序栈也使用数组实现. 一般将栈底设置在数组最低端 (下标 0), 并设置栈顶指针指示栈顶位置.

当栈满时, 进栈会导致**上溢**; 当栈空时, 退栈会导致**下溢**.

@see SeqStack.c

如果将多个栈分配在同一个顺序存储空间内, 则可以相互进行调节, 即节约空间, 又可降低发生溢出的概率. 可以将两个栈的栈底分别设在顺序存储空间的两端, 让两个栈各自向中间延伸.

---

栈的链式存储结构称为**链栈**, 它是运算受限的单链表. 不必设置头结点. 可以克服顺序栈的溢出和空间浪费问题.

---

栈的应用非常广泛, 只要问题满足 LIFO 原则, 都可使用栈作为数据结构, 如
- 圆括号匹配的检验 @see SeqStack.c:Expr
- 字符串回文的判断 @see SeqStack.c:symmetry
- 数值转换 @see SeqStack.c:conversion
- 通过递归工作栈, 实现递归
- 实现程序设计语言的函数调用和返回

## 队列

**队列**也是一种操作受限的线性表, 它只允许在表的一端进行插入, 而在另一端进行删除. 插入的一端称为**队尾**, 删除的一端称为**队头**. 元素的插入称为**入队**, 删除称为**出队**. 又称队列为**先进先出 (FIFO) 表**.

队列的顺序存储结构称为**顺序队列**. 需要设置队头指针 front 和队尾指针 rear. 它们的初值为 0.
入队时, 将元素插入队尾指针所指位置, 并将队尾指针加 1.
出队时, 将队头指针加 1, 并返回被删除的元素.
头尾指针相等时队列为空.

@see SeqQueue.c

如果用数组实现顺序队列, 当队尾指针指向数组最后一个元素时, 继续插入新元素, 则会发生上溢, 而出队的位置又无法再利用. 为了克服这两个问题, 可将数组想象为一个环状空间, 称这种环状数组表示的队列为**循环队列**.
- 可用求余运算, 判断发生上溢时, 进入下一个循环.
- 队列无论是空是满, 都有 队头指针 == 队尾指针.

    为了判断队列是空是满, 有几种常用方法:
    - 另设一个标志位, 标记队列是空是满
    - 设置计数器记录队列中元素个数
    - 少用一个元素空间, 即 rear 所指向的单元始终为空. 约定入队前, 测试 rear + 1 是否等于头指针. 是则队满.

@see CirQueue.c

---

队列的链式存储结构称为**链队列**.
需增设一个尾指针以方便在表尾做插入操作.
于是一个链队列就由一个头指针和一个尾指针唯一确定.
为了简化边界条件的处理, 队头结点之前也附加一个头结点, 并设头指针指向此结点.

@todo 图

@see LinkQueue.c

---

用一个带头结点的循环单链表表示队列, 成为**循环链队列**.

该队列只设一个队尾结点指针 rear, 不设头指针. 且 rear->next 回指到头结点.

@see CirLinkQueue.c

---

栈和队列的应用实例: 中缀表达式的计算

我们平时写的计算式如 8+5*(7-3), 因为运算符放到操作数中间, 称为**中缀表达式** (逆波兰表示法). 为了方便计算机处理, 可以把运算符放到操作数后面, 即**后缀表达式**. 如 8 5 7 3 - * +. 要计算该表达式, 可以从左向右扫描, 直到遇到一个运算符后即开始运算. 遇到 -, 计算 7-3, 得到 4, 原计算式变为 854*+; 遇见 *, 计算 5*4=20, 计算式变为 8 20 +; 遇见 +, 计算 8 + 20 = 28. 得到了最终结果. 后缀表达式的这种计算规则, 正是运用栈和队列的典型例子.

- 先通过栈将中缀表达式变为后缀表达式:

    从例子中可以看到, 将中缀表达式变为后缀表达式时, 运算符依据优先级从高到低从左向右的排列. 转换过程如下:
    1. 顺序扫描中缀表达式, 遇到数字时, 将其送至输出队列中
    2. 遇到运算符时, 将栈中所有优先级高于或等于该运算符的运算符弹出, 送至输出队列, 再将当前运算符入栈
    3. 遇到左括号时, 入栈
    4. 遇到右括号时, 将靠近栈顶的第一个左括号上面的运算符全部依次弹出, 送至输出队列中, 再删除栈中的左括号

- 然后计算后缀表达式

    因为运算符已经按照优先级顺序排好, 所以很容易用计算机实现. 因为计算后缀表达式时, 最后保存的值最先取出参与运算, 所以需要栈保存中间结果.

@see PostExp.c

# 多维数组和广义表

## 多维数组

当数组维数为 1 时, 它是一种元素个数固定的线性表. 当是多维数组时, 它可以看成是线性表的推广. 以二维数组为例:

    a1 a2 a3 a4
    b1 b2 b3 b4
    c1 c2 c3 c4

- 除了边界元素外, 每个元素都有分别位于行向量上和列向量上的两个直接前趋和两个直接后继. 如 b2 的两个直接前趋为 b1 和 a2, 两个直接后继为 b3 和 c2
- 开始结点 (a1) 没有前趋, 终端结点 (c4) 没有后继
- 边界上的结点只有行或列上的一个直接前趋或一个直接后继. 如 b1 只有一个前趋结点 a1, b4 只有一个后继结点 c4

@see Array.c

## 矩阵的压缩存储

矩阵一般用数组来存储.

**特殊矩阵**指的是相同值的元素或者零元素在矩阵的分布有一定规律的矩阵. 可以对这类矩阵采取压缩存储.

---

**对称矩阵**: 元素关于主对角线对称分布. 则只需要存储矩阵上三角或下三角元素. 如下面的矩阵

    00
    10  11
    20  21  22
    ...

假设行数为 n, 可以看出, 如果把上面的矩阵存储到一维数组中, 则总共需要 n(n+1)/2 个空间.

而且矩阵中元素 ij 对应到以为数组位置 k 有如下关系:
- 如果 i>=j, 则 ij 位于下三角: `k = i * (i + 1) / 2 + j`
- 如果 i<j,  则 ij 位于上三角: `k = j * (j + 1) / 2 + i`

@see SymMatrix.c

---

**三角矩阵**指矩阵的对角线上方或下方均为常数或零的方阵. 分别称为下三角矩阵或上三角矩阵.

比之对称矩阵, 需额外存储重复的元素. 故需要 n(n+1)/2+1 个空间.

对于上三角矩阵, 矩阵元素 ij 对应到数组位置 k 的关系为:
- 如果 i<=j, 则 ij 位于上三角: `k = i * (2n - i + 1) / 2 + j - i`
- 如果 i>j, 则存储于最后一项: `k = n (n + 1) / 2`

对于下三角矩阵, 矩阵元素 ij 对应到数组位置 k 的关系为:
- 如果 i>=j, 则 ij 位于下三角, 类似对称矩阵: `k = i * (i + 1) / 2 + j`
- 如果 i>j, 则存储于最后一项: `k = n (n + 1) / 2`

---

**稀疏矩阵**是非零元素的分布没有规律的矩阵, 因此在存储非零元素值时, 还需同时存储该元素的行列位置, 所以可用一个称为三元组 `(i, j, a[i][j])` 来唯一确定一个非零元素. 对稀疏矩阵的压缩存储通常有顺序存储和链式存储两种方法.
- 链式存储一般用十字链表法, 比较复杂, 不做介绍
- 顺序存储: 将三元组按行优先的顺序排列, 可得到一个其结点均为三元组的线性表, 称为**三元组表**


为了便于随机存取**任一行**的非零元素, 可以在三元组表表示的系数矩阵中额外存储每一行的第一个非零元素在三元组表中位置的数组. 这样的表示叫做**带行表的三元组表**, 又称为**行逻辑连接的顺序表**.


@see TSMatrix.c

## 广义表基础

**广义表**是线性表的推广, 又称列表. 线性表中的元素仅限于原子项, 如果放松这种限制, 允许它们自身具有结构, 就产生了广义表的概念. 广义表是 n 个元素的有限序列, 其中的元素或者是原子项, 或者是一个广义表. n 为它的长度, 内层的广义表称作**字表**. 嵌套的层数称为它的**深度**. 称第一个元素为表头, 称**其余元素组成的表**为**表尾**. 显然, 广义表是一个递归定义, 它是一种多层次的非线性结构. 它不仅是线性表的推广, 也是树结构的推广.

广义表通常记为 LS=(a1, a2, ..., an).

注意, () 和 (()) 是不同的. 前者是空表, 长度为 0, 后者是由空表做元素的广义表, 长度为 1.

通常采用链式存储结构表示广义表.

@see GList.c

# 树和二叉树

树形结构是一个递归结构. **树**是 n(n>=0) 个结点的有限集. 它是空集, 或者是非空集. 对于任意一棵非空树:
- 有且仅有一个特定的称为**根**的结点
- 当 n > 1 时, 其余结点可分为互不相交的有限集, 其中每个集合本身又是一棵树, 并称为根的**子树**

一般可以用以下几种表示法表示一棵树:
- 树形图表示法
- 嵌套集合的形式
- 凹形表示法
- 广义表形式

@todo 图

树的**结点**包含一个数据元素及若干个指向其子树的**分支**. 一个结点的子树数叫做结点的**度**. 最大的度称为该树的度. 度数为零的结点称为**叶子**结点或**终端**结点, 不为零的称为**非终端**结点或**分支结点**. 分支结点也叫内部节点, 而根结点又称为开始结点.

## 二叉树

**二叉树**的每个结点至多只有两颗子树. 并分别叫做根的左子树和右子树. 它可以是空集.

性质:
- 第 i 层至多有 2^(i-1) 个结点
- 深度为 k 的二叉树至多有 2^k-1 个结点. 把有 2^k-1 个结点的树叫做**满二叉树**
- 终端结点数等于度数为 2 的结点数再加 1
- 具有 n 个结点的完全二叉树的深度为 floor(logN) + 1 或 ceil(log(N+1))

**完全二叉树**只深度为 k 的二叉树, 前 k-1 层是一颗满二叉树, 而最下一层的结点都集中在最左边的若干位置.

对于具有 N 个结点的完全二叉树, 从树根开始自上到下自左到右的为每个结点编号, 则可以根据编号 i 可推导其父结点和子结点编号:
- 若 i=0, 则该结点为根结点, 无双亲. 若 i != 0, 则该结点的双亲编号为 floor((i-1)/2)
- 若 2i+1 < n, 则该结点的左孩子结点编号为 2i+1, 否则无左孩子, 即该结点必定是叶子结点
- 若 2i+2 < n, 则该结点的右孩子结点编号为 2i+2, 否则无右孩子

顺序存储结构
对于完全二叉树来说, 顺序存储结构既简单有节省存储空间. 而且对于插入和删除操作, 需要移动大量结点.
对于一般的二叉树, 必须增加一些虚结点使其成为完全二叉树, 这样的话会造成存储空间上的浪费.

链式存储结构
设计不同的结点可构成不同形式的链式存储结构. 通常是为每个结点设置三个域, 值域, 左指针域和右指针域. 有时为了便于查找结点双亲, 还可以增加一个指向双亲的指针.

称为**二叉链表**.

@see BinTree.c

遍历二叉树是二叉树中所有其他运算的基础. 所谓遍历, 指沿着某条搜索路径一次对树中每个节点访问, 且仅访问一次.
遍历一颗二叉树可分解为三步: 访问根结点 D, 遍历左子树 L, 和遍历右子树 R. 则有 DLR,  LDR, LRD 和 DRL, RDL, RLD 六种次序的遍历方案. 由于后三种和前三种对称, 仅讨论前三种.

DLR: 在访问子树前访问根结点, 称为**前序遍历**或**先根遍历**. 类似的
LDR: **中序遍历**
LRD: **后序遍历**

由二叉树的中序和前序遍历序列, 或者中序和后序遍历序列, 可唯一的确定一颗二叉树. 具体方法如下:
1. 根据前序或后续序列确定二叉树的各子树的根
2. 根据中序序列确定各子树根的左右子树

如前序序列为 abdeghcfi, 中序序列为 dbgehacif, 求二叉树:
1. 前序序列确定二叉树的根为 a, 再由中序序列确定 a 的左右子树
- a | bdegh | cfi     前序序列确定: 根, 左子树,右子树
- dbgeh | a | cif     中序序列确定: 左子树, 根, 右子树
2. 确定 a 的左子树
- b | d | egh         前序序列确定: 根, 左子树, 右子树
- d | b | geh         中序序列确定: 左子树, 根, 右子树
3. 再确定 b 的右子树: 唯一确定 e 为根, g 和 h 分别为左子树和右子树
- e | g | h           前序序列确定: 根, 左子树, 右子树
- g | e | h           中序序列确定: 左子树, 根, 右子树
4. 确定 a 的右子树
- c | fi              前序序列确定: 根, 右子树
- c | if              中序序列确定: 根, 右子树
5. 确定 c 的右子树
- f | i               前序序列确定: 根, 左子树
- i | f               中序序列确定: 左子树, 根

最终确定的树如下:

            a
          /   \
        b      c
      /  \       \
    d     e        f
         /  \     /
        g    h   i

## 线索二叉树

遍历二叉树以得到一个线性序列, 实质上是对一个非线性结构的**线性化操作**, 使得每个结点在序列中有且仅有一个直接前趋和一个直接后继.

使用二叉链表存储二叉树时, 因为每个结点之后指向左右子树的指针域, 不方便其前趋和后继结点的查找. 为了找到结点的直接前趋和后继, 可以在每个结点中增加前趋指针和后继指针域. 但这样会降低存储空间利用率.

另一方面. n 个结点的二叉链表中必定存在 n+1 个空指针域 (因为 n 个结点一共有 2n 个指针, 其中根结点不占用指针, 所以占用的指针为 n-1 个, 还剩 2n-(n-1)=n+1 个空指针域), 可以利用这些空指针域存放前趋和后继指针, 这些指针称为**线索**. 相应的二叉链表称为**线索链表**, 相应的二叉树称为**线索二叉树**. 而加线索的过程即**线索化**.

按照某种次序遍历二叉树, 遍历过程中用线索取代空指针即可实现线索化.

@see BinThrTree.c

## 树和森林

@see Tree.c

存储结构: @TODO image

双亲表示法: 树结构中每个结点的双亲是唯一的. 如果以一组连续空间 (数组) 存储树的结点, 同时为每个结点附加一个指向双亲的指针, 就可唯一的表示一棵树. 这种表示法方便查找双亲操作.

孩子链表法: 把每个结点的孩子结点看成一个线性表, 并以单链表结构存储其孩子结点. n 个结点就有 n 个孩子链表. 为了便于查找, 将树中各结点的孩子链表的头结点存放在一个指针数组中. 这种表示法方便查找孩子结点操作.

带双亲的孩子链表法: 将上述两种表示法结合起来, 既方便查找双亲, 也方便查找孩子.

孩子兄弟表示法: 又称二叉链表表示法. 即以二叉链表作为树的存储结构. 链表中两个链指针域分别指向该结点的第一个孩子结点和下一个兄弟结点. 这种方式的优点是, 它和二叉链表表示完全一样, 可利用二叉树的各种算法实现对树的操作.

---

给定一棵树, 可以找到唯一的一颗二叉树与之对应. 从物理结构上看它们是相同的, 只是解释不同而已.

将树转换为二叉树:
1. 首先在所有兄弟结点之间加一道线
2. 然后再对每个结点保留长子的连线, 去掉该结点与其他孩子的连线

将森林转换为二叉树:
1. 先将每一棵树转化成二叉树
2. 再将二叉树的根节点看作是兄弟连在一起, 形成一颗二叉树

将二叉树转换成树或森林:
1. 若结点 x 是双亲 y 的左孩子, 则把 x 的右孩子, 右孩子的右孩子... 都与 y 连起来
2. 去掉所有双亲到右孩子的连线

---

树的遍历

- 前序遍历

    先访问树的根结点, 然后依次前序遍历根的每颗子树.
    等价于前序遍历该树对应的二叉树

- 后序遍历

    限一次后序遍历根的每颗子树, 然后访问根结点
    等价于中序遍历该树对应的二叉树

森林的遍历

- 前序遍历

    从左到右依次按前序次序遍历森林中的每一棵树
    等价于前序遍历森林对应的二叉树

- 后序遍历

    从左到右依次按后序次序遍历森林中的每一棵树
    等价于中序遍历森林对应的二叉树

## 哈弗曼树

@see HuffmanTree.c

两个节点构成的路径上的边的数目称为**路径长度**. 树根到树中每个节点的路径长度称为**树的路径长度**.

为结点赋上具有某种意义的数, 称为该结点的**权**. 从树根结点到某结点之间的路径长度与该结点的权的乘积称为该结点的**带权路径长度**. 树中所有叶子结点的带权路径长度之和称为**树的带权路径长度**.

带权路径长度最小的二叉树称为**哈弗曼树**或**最优二叉树**.
一般利用哈夫曼树可以得到最佳的判定算法.

若叶结点上的权值均相同, 其中完全二叉树一定是最优二叉树, 否则不一定是最优二叉树.

利用哈夫曼算法可以构造最优二叉树. 步骤如下:
1. n 个带权值的相互孤立的叶子结点, 组成一个森林
2. 选出两个权值最小的结点, 作为左右子树, 构成一个新树. 置新树的根结点为左右子树的权值之和
3. 从森林中删除刚才选出的两个节点, 把新树加入到森林
4. 重复 2, 3. 直到森林中只剩下一棵树为止, 这棵树就是哈夫曼树

可见, n 个叶子结点需要合并 n-1 次, 产生 n-1 个新结点, 因此最终的哈弗曼树含有 2n-1 个结点.

---

对于 n 中字符, 根据其在报文中出现的频率, 作为其权, 然后构造一颗哈弗曼树. 把树中的做分支约定为 0, 右分支约定为 1, 取每条路径上的 0, 1 序列作为叶子结点对应字符的字符编码. 这就是**哈弗曼编码**.

哈夫曼编码也是一种**前缀编码**, 即保证任意字符的编码都不是另一个字符编码的前缀.

# 图

**图**是一种复杂的非线性结构. 在图形结构中, 结点之间的关系可以是任意的.

若图中每条边都是有方向的, 则该图为**有向图**. 连接两个结点的边则为**有向边**. 有向边又称为**弧**, 边的起点称为**弧尾**, 终点称为**弧头**.

若每条边都没有方向, 则该图为**无向图**.

边两端的结点互为**邻接点**, 或称它们彼此**相邻接**.